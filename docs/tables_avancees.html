<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="UTF-8">
        <title>Tables avancées sur Attila</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
        <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    </head>
    <body>
    <section class="page-header">
        <h1 class="project-name">Tables avancées sur Attila</h1>
        <h2 class="project-tagline">Attila est un ORM PHP</h2>
        <a href="https://github.com/vyctory/venusframework" class="btn">Vu sur GitHub</a>
        <a href="https://github.com/vyctory/venusframework/zipball/master" class="btn">Télécharger .zip</a>
        <a href="https://github.com/vyctory/venusframework/tarball/master" class="btn">Télécharger .tar.gz</a>
    </section>

    <section class="main-content">

        <a href="les_joins.html">[précédent]</a>

        <h3>
            <a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true">
                <span aria-hidden="true" class="octicon octicon-link"></span>
            </a>Tables avancées</h3>

        Venus permet de définir des compléments d’information sur les tables que vous voulez créer comme le moteur
        utilisé, l’auto-increment de départ et le charset par défaut de la table. Voici un exemple de table avec ce type
        de définition :

        <pre>
"board": {
    "fields": {
        "id": {
            "type": "int",
            "key": "primary",
            "null": false,
            "unsigned": true,
            "autoincrement": true
        },
        "name": {
            "type": "varchar",
            "value": "50",
            "null": false
        },
        "id_role": {
            "type": "int",
            "value": "10",
            "null": false,
            "join": "role",
            "join_by_field": "id",
            "join_delete": "cascade",
            "join_update": "cascade",
            "constraint": "role_fk"
        },
        "id_user": {
            "type": "int",
            "value": "10",
            "null": false,
            "join": "user",
            "join_by_field": "id",
            "join_delete": "cascade",
            "join_update": "cascade",
            "constraint": "user_fk"
        }
    },
    "engine": "InnoDB",
    "auto_increment": 3,
    "default_charset": "utf8"
}
        </pre>

        Venus permet de définir des index de deux façons différentes (soit groupé, soit directement sur les champs en
        question). On ne pourra créer des index multiple que dans la première façon de faire en revanche. Voici deux
        exemples de table avec ce type de définition :

        <pre>
"user": {
    "fields": {
        "id": {
            "type": "int",
            "key": "primary",
            "null": false,
            "unsigned": true,
            "autoincrement": true
        },
        "id_team": {
            "type": "int",
            "null": false,
            "unsigned": true
        }
    },
    "index": [
        "id_team_name_index": ["id_team"]
    ],
    "engine": "InnoDB",
    "auto_increment": 1,
    "default_charset": "utf8"
},

(ou)

"user": {
    "fields": {
        "id": {
            "type": "int",
            "key": "primary",
            "null": false,
            "unsigned": true,
            "autoincrement": true
        },
        "id_team": {
            "type": "int",
            "null": false,
            "unsigned": true,
            "key": “index”
        }
    },
    "engine": "InnoDB",
    "auto_increment": 1,
    "default_charset": "utf8"
},
        </pre>

        Attila permet de définir des champs uniques de deux façons différentes (soit groupé, soit directement sur les
        champs en question). On ne pourra créer des champs uniques multiples que dans la première façon de faire en
        revanche. Voici deux exemples de table avec ce type de définition :

        <pre>
"user": {
    "fields": {
        "id": {
            "type": "int",
            "key": "primary",
            "null": false,
            "unsigned": true,
            "autoincrement": true
        },
        "id_team": {
            "type": "int",
            "null": false,
            "unsigned": true
        }
    },
    "unique": [
        "id_team_name_index": ["id_team"]
    ],
    "engine": "InnoDB",
    "auto_increment": 1,
    "default_charset": "utf8"
},

(ou)

"user": {
    "fields": {
        "id": {
            "type": "int",
            "key": "primary",
            "null": false,
            "unsigned": true,
            "autoincrement": true
        },
        "id_team": {
            "type": "int",
            "null": false,
            "unsigned": true,
            "key": “unique”
        }
    },
    "engine": "InnoDB",
    "auto_increment": 1,
    "default_charset": "utf8"
},
        </pre>
        
        <a href="xxx.html">[suivant]</a>
    </body>
</html>
